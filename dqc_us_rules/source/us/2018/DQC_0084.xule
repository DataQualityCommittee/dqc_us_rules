/**
DQC Rules
 (c) Copyright 2017 - 2019, XBRL US Inc. All rights reserved.
 See https://xbrl.us/dqc-license for license information.
 See https://xbrl.us/dqc-patent for patent infringement notice.
Taxonomy: US GAAP 2018
**/


rule-name-prefix DQC

assert US.0084.9298 satisfied

$rule_id = (rule-name().split('.'))[rule-name().split('.').length];

$decimal_tolerance_factor = 2;

$fact1 = {@period = * where $fact.concept.is-monetary and $fact.concept.period-type == duration
	  	 	    and not $fact.concept.name.local-name.lower-case.contains('average')
	  	 	   and not $non_additive_duration_concepts.contains($fact.concept.name)};
				

$sub-periods =  
		$p1 = {@period=* where ($fact.period.start + time-span("P0D")) == ($fact1.period.start + time-span("P0D")) and $fact.period.end < $fact1.period.end};
		$p2 = {@period=* where ($fact.period.start + time-span("P0D")) == ($p1.period.end + time-span("P0D"))};
		if (($p2.period.end + time-span("P0D")) == ($fact1.period.end + time-span("P0D")))
			list($p1, $p2)
			
		else
			$p3 = {@period = * where ($fact.period.start + time-span("P0D")) == ($p2.period.end + time-span("P0D"))};
			if (($p3.period.end + time-span("P0D")) == ($fact1.period.end + time-span("P0D")))
				list($p1, $p2, $p3)
			else
				$p4 = {@period=* where ($fact.period.start + time-span("P0D")) == ($p3.period.end + time-span("P0D"))};
				if (($p4.period.end + time-span("P0D")) == ($fact1.period.end + time-span("P0D")))
					list($p1, $p2, $p3, $p4)
				else
					skip
					;
					
if not exists($sub-periods)
	false
else
	$sum-periods = sum(list(for ($x in $sub-periods) $x));
	$all-decimals = set(for ($y in $sub-periods) $y.decimals);
	$min-decimals = min(filter $all-decimals where $item.decimals != INF );
	
	$it-does-not-sum = 
		if ($min-decimals == none)
			if $fact1.decimals == inf
				$fact1 != $sum-periods;
			else
				$min_dec_tolerance1 = $fact1.decimals;
				$tolerance = (10.power(-1 * $min_dec_tolerance1)) * $decimal_tolerance_factor;
				(abs(round($fact1,$min_dec_tolerance1) - round($sum-periods,$min_dec_tolerance1)) > $tolerance);
			
		else
			if $fact1.decimals == inf
				$fact_decimals = 0;
			else
				$fact_decimals = $fact1.decimals;
				
			$min_dec_tolerance1 = 	if ($fact_decimals < $min-decimals) 
										$fact_decimals
									else 	
										$min-decimals;	
			$tolerance = (10.power(-1 * $min_dec_tolerance1)) * $decimal_tolerance_factor;
			
			(abs(round($fact1,$min_dec_tolerance1) - round($sum-periods,$min_dec_tolerance1)) > $tolerance);
			
	if $it-does-not-sum
		$period-message = (filter $sub-periods returns "\t" + $item.period.string +"\t" + $item.string).join("\n");
		if (is_base($fact1.concept))
            $error_code = "error";
			true
		else
			false
	else
		false
message
"Sum of the cumulative periods of {$sum-periods} for {$fact1.concept.name} does not match the reported total of {$fact1}\n\nPeriod values are:\n{$period-message}\n\nThis rule takes into account possible rounding of values across periods and the decimals associated with each fact. If there is a difference between the sum of the periods and the aggregate value reported the difference may be due to incorrect decimals associated with the individual fact values. The filer should check that the fact values do not have a decimal value that implies a higher level of accuracy than intended.

The rule excludes elements in the base taxonomy that cannot be aggregated such as concepts that represent an average.

The properties of this {$fact1.concept.name} fact are:

Period :{$fact1.period}
Dimensions : {$fact1.dimensions.join(', ','=')}
Unit : {$fact1.unit}
Decimals: {$fact1.decimals}

Rule Element Id:{$rule_id}
Rule version: {$ruleVersion}"

severity $error_code

effectiveDate $effective_dates[$rule_id]

rule-focus $fact1

constant $non_additive_duration_concepts = set()