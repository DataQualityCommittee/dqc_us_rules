/**
DQC Rules
 (c) Copyright 2017 - 2019, XBRL US Inc. All rights reserved.
 See https://xbrl.us/dqc-license for license information.
 See https://xbrl.us/dqc-patent for patent infringement notice.
Taxonomy: US GAAP 2018
**/


rule-name-prefix DQC

assert US.0084.9298 satisfied

$rule_id = (rule-name().split('.'))[rule-name().split('.').length];

$decimal_tolerance_factor = 2;

$fact1 = {@period = * where $fact.concept.is-monetary and $fact.concept.period-type == duration
	  	 	    and not $fact.concept.name.local-name.lower-case.contains('average')
	  	 	   and not $non_additive_duration_concepts.contains($fact.concept.name)};
				

$sub-periods =  
		$p1 = {@period=* where ($fact.period.start + time-span("P0D")) == ($fact1.period.start + time-span("P0D")) and $fact.period.end < $fact1.period.end};
		$p2 = {@period=* where ($fact.period.start + time-span("P0D")) == ($p1.period.end + time-span("P0D"))};
		if (($p2.period.end + time-span("P0D")) == ($fact1.period.end + time-span("P0D")))
			list($p1, $p2)
			
		else
			$p3 = {@period = * where ($fact.period.start + time-span("P0D")) == ($p2.period.end + time-span("P0D"))};
			if (($p3.period.end + time-span("P0D")) == ($fact1.period.end + time-span("P0D")))
				list($p1, $p2, $p3)
			else
				$p4 = {@period=* where ($fact.period.start + time-span("P0D")) == ($p3.period.end + time-span("P0D"))};
				if (($p4.period.end + time-span("P0D")) == ($fact1.period.end + time-span("P0D")))
					list($p1, $p2, $p3, $p4)
				else
					skip
					;
					
if not exists($sub-periods)
	false
else
	$sum-periods = sum(list(for ($x in $sub-periods) $x));
	$all-decimals = set(for ($y in $sub-periods) $y.decimals);
	$min-decimals = min(filter $all-decimals where $item.decimals != INF );
	
	$it-does-not-sum = 
		if ($min-decimals == none)
			if $fact1.decimals == inf
				$fact1 != $sum-periods
			else
				$min_dec_tolerance1 = $fact1.decimals;
				$tolerance = (10.power(-1 * $min_dec_tolerance1)) * $decimal_tolerance_factor;
				(abs(round($fact1,$min_dec_tolerance1) - round($sum-periods,$min_dec_tolerance1)) > $tolerance)
			
		else
			if $fact1.decimals == inf
				$fact1 != $sum-periods
			else
				
				$fact_decimals = $fact1.decimals;
				
			$min_dec_tolerance1 = 	if ($fact_decimals < $min-decimals) 
										$fact_decimals
									else 	
										$min-decimals;	
			$tolerance = (10.power(-1 * $min_dec_tolerance1)) * $decimal_tolerance_factor;
			
			(abs(round($fact1,$min_dec_tolerance1) - round($sum-periods,$min_dec_tolerance1)) > $tolerance)
			
	if $it-does-not-sum
		$period-message = (filter $sub-periods returns "\t" + $item.period.string +"\t" + $item.string).join("\n");
		if (is_base($fact1.concept,$all_base_taxonomies))
            $error_code = "error";
			true
		else
			false
	else
		false
message
"Sum of the cumulative periods of {$sum-periods} for {$fact1.concept.name} does not match the reported total of {$fact1}\n\nPeriod values are:\n{$period-message}\n\nThis rule takes into account possible rounding of values across periods and the decimals associated with each fact. If there is a difference between the sum of the periods and the aggregate value reported the difference may be due to incorrect decimals associated with the individual fact values. The filer should check that the fact values do not have a decimal value that implies a higher level of accuracy than intended.

The rule excludes elements in the base taxonomy that cannot be aggregated such as concepts that represent an average.

The properties of this {$fact1.concept.name} fact are:

Period :{$fact1.period}
Dimensions : {$fact1.dimensions.join(', ','=')}
Unit : {$fact1.unit}
Decimals: {$fact1.decimals}

Rule Element Id:{$rule_id}
Rule version: {$ruleVersion}"




assert US.0084.9299 satisfied

$rule_id = (rule-name().split('.'))[rule-name().split('.').length];

$decimal_tolerance_factor = 2

$fact1 = {@period = * where $fact.concept.is-monetary and $fact.concept.period-type == duration
	  	 	    and not $fact.concept.name.local-name.lower-case.contains('average')
	  	 	    and not $non_additive_duration_concepts.contains($fact.concept.name)};
				

$sub-periods =  

		$p1 = {@period=* where ($fact.period.start + time-span("P0D")) == ($fact1.period.start + time-span("P0D")) and $fact.period.end < $fact1.period.end};
		$p2 = {@period=* where ($fact.period.start + time-span("P0D")) == ($p1.period.end + time-span("P0D"))};
		if (($p2.period.end + time-span("P0D")) == ($fact1.period.end + time-span("P0D")))
			list($p1, $p2)
			
		else
			$p3 = {@period = * where ($fact.period.start + time-span("P0D")) == ($p2.period.end + time-span("P0D"))};
			if (($p3.period.end + time-span("P0D")) == ($fact1.period.end + time-span("P0D")))
				list($p1, $p2, $p3)
			else
				$p4 = {@period=* where ($fact.period.start + time-span("P0D")) == ($p3.period.end + time-span("P0D"))};
				if (($p4.period.end + time-span("P0D")) == ($fact1.period.end + time-span("P0D")))
					list($p1, $p2, $p3, $p4)
				else
					skip
					;
					
if not exists($sub-periods)
	false
else
	$sum-periods = sum(list(for ($x in $sub-periods) $x));
	$all-decimals = set(for ($y in $sub-periods) $y.decimals);
	$min-decimals = min(filter $all-decimals where $item.decimals != INF );
	
	$it-does-not-sum = 
		if ($min-decimals == none)
			$fact1 != $sum-periods
		else
			$componentNum = $sub-periods.length;
			$scale = 10.power($min-decimals * - 1);
			$tolerance = ($componentNum - 1) * $scale * $decimal_tolerance_factor;
			
			($fact1 - $sum-periods).abs > $tolerance;
	if $it-does-not-sum
		$period-message = (filter $sub-periods returns "\t" + $item.period.string +"\t" + $item.string).join("\n");
		if (is_base($fact1.concept, $all_base_taxonomies))
            $error_code = "error";
			true
		else
			false
	else
		false
message
"Sum of the cumulative periods of {$sum-periods} for {$fact1.concept.name} does not match the reported total of {$fact1}\n\nPeriod values are:\n{$period-message}\n\nThis rule takes into account possible rounding of values across periods and the decimals associated with each fact. This rule used a tolerance of {$tolerance} which is calculated by taking the lowest decimal value used in the calculation of {$min-decimals} If there is a difference between the sum of the periods and the aggregate value reported the difference may be due to incorrect decimals associated with the individual fact values. The filer should check that the fact values do not have a decimal value that implies a higher level of accuracy than intended.\n\nIf the element {$fact1.concept.name} represents an average, maximum or minimum of the range of values rather than a sum of the values then this rule should be ignored. The rule excludes elements in the base taxonomy that cannot be aggregated. However, this cannot always be accurately determined for extension elements.

The properties of this {$fact1.concept.name} fact are:

Period :{$fact1.period}
Dimensions : {$fact1.dimensions.join(', ','=')}
Unit : {$fact1.unit}
Decimals: {$fact1.decimals}

Rule Element Id:{$rule_id}
Rule version: {$ruleVersion}"

severity $error_code

effectiveDate $effective_dates[$rule_id]

rule-focus $fact1

constant $non_additive_duration_concepts = set()