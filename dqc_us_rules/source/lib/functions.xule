/** 
DQC Rules
 (c) Copyright 2017 - 2025, XBRL US Inc. All rights reserved.
 See https://xbrl.us/dqc-license for license information.
 See https://xbrl.us/dqc-patent for patent infringement notice.
 Shared Function Library IFRS & US & esef
**/

/** 
 * compare_baseCalc_to_extensionCalc
 * 
 * This function compares the calc in the base taxonomy to the calc in the extension taxonomy to identify any common elements.
 * 
 * @param concept - $baseConcept - Passes base taxonomy concept .
 * @param taxonomy - $baseTaxonommy - Passes the base taxonomy to use .  i.e. $US-GAAP
 * @param concept - $extensionConcept - Passes extension taxonomy concept.
 * @param list - $exceptions - Passes a list of exception items to exclude. i.e. cashflow_exceptions
 * @return set - Returns a set of target qnames.
 **/

function compare_baseCalc_to_extensionCalc($base_concept, $base_taxonomy, $extension_concept, $exceptions)
	$extensionNames = navigate summation-item descendants from $extension_concept returns set (target-name) 
	navigate summation-item descendants from $base_concept taxonomy $base_taxonomy  where $relationship.target.name in $extensionNames and not ($relationship.target.name in $exceptions) returns set (target-name) 

/** 
 * is_extension
 * 
 * This function Checks if the concept is an extension taxonomy element  .
 * 
 * @param concept - $test_extension - Passes concept to check if it is an extension concept.
 * @param set - $base_taxonomies - Set of taxonomies that comprise the base taxonomies.
 * @return boolean - Returns true if the concept is an extension concept.
 **/

function is_extension($test_extension, $base_taxonomies)
		all(filter $base_taxonomies returns $item.concept($test_extension.name) == none)
	
/** 
 * is_base
 * 
 * This function Checks if the concept is a base taxonomy element  .
 * 
 * @param concept - $test_base - Passes concept to check if it is a base concept.   
  * @param concept - $base_taxonomies - Set of taxonomies that comprise the base taxonomies. -> $ALL_BASE_TAXONOMIES
 * @return boolean - Returns true if the concept is a base concept.
**/

function is_base($test_base, $base_taxonomies)
	any(filter $base_taxonomies returns $item.concept($test_base.name) != none)

/** 
 * effective_weight_is_positive
 * 
 * This function checks if effective weight between two concepts is positive.
 * 
 * @param concept - $topConcept - Passes a parent concept to determine the effective weight relative to a calculation decendant.
 * @param concept - $bottomConcept - Passes a descendant concept to compare against an ancestor defined in the first parameter
 * @return boolean - Returns true if the effective weight is positive else returns false
**/

function effective_weight_is_positive($topConcept,$bottomConcept)
	$effectiveWeight = taxonomy().effective-weight-network($topConcept, $bottomConcept);
	for ($network in $effectiveWeight)
		$network[1] > 0

/** 
 * effective_weight_is_positive_network
 * 
 * This function checks if effective weight between two concepts is positive.
 * 
 * @param concept - $topConcept - Passes a parent concept to determine the effective weight relative to a calculation decendant.
 * @param concept - $bottomConcept - Passes a descendant concept to compare against an ancestor defined in the first parameter
 * @param concept - $network_role - Passes a network role.
 * @return boolean - Returns true if the effective weight is positive else returns false
**/

function effective_weight_is_positive_network($topConcept,$bottomConcept,$network_role)
	$effectiveWeight = taxonomy().effective-weight-network($topConcept, $bottomConcept, $network_role);
	for ($network in $effectiveWeight)
		$network[1] > 0

/** 
 * effective_weight_is_negative
 * 
 * This function checks if effective weight between two concepts is negative
 * 
 * @param concept - $topConcept - Passes a parent concept to determine the effective weight relative to a calculation decendant.
 * @param concept - $bottomConcept - Passes a descendant concept to compare against an ancestor defined in the first parameter
 * @return boolean - Returns true if the effective weight is negative else returns false
**/

function effective_weight_is_negative($topConcept,$bottomConcept)
	$effectiveWeight = taxonomy().effective-weight-network($topConcept, $bottomConcept);
	for ($network in $effectiveWeight)
		$network[1] < 0


/** 
 * effective_weight_is_negative_network
 * 
 * This function checks if effective weight between two concepts is negative
 * 
 * @param concept - $topConcept - Passes a parent concept to determine the effective weight relative to a calculation decendant.
 * @param concept - $bottomConcept - Passes a descendant concept to compare against an ancestor defined in the first parameter
 * @param concept - $network_role - Passes a network role.
 * @return boolean - Returns true if the effective weight is negative else returns false
**/

function effective_weight_is_negative_network($topConcept,$bottomConcept, $network_role)
	$effectiveWeight = taxonomy().effective-weight-network($topConcept, $bottomConcept, $network_role);
	for ($network in $effectiveWeight)
		$network[1] < 0

/** 
 * effective_weight_is_zero_network
 * 
 * This function checks if effective weight between two concepts is negative
 * 
 * @param concept - $topConcept - Passes a parent concept to determine the effective weight relative to a calculation decendant.
 * @param concept - $bottomConcept - Passes a descendant concept to compare against an ancestor defined in the first parameter
 * @param concept - $network_role - Passes a network role.
 * @return boolean - Returns true if the effective weight is negative else returns false
**/

function effective_weight_is_zero_network($topConcept,$bottomConcept, $network_role)
	$effectiveWeight = taxonomy().effective-weight-network($topConcept, $bottomConcept, $network_role);
	for ($network in $effectiveWeight)
		$network[1] == 0
		
		
/**
 * get_member_dims
 *
 * This function returns a dictionary of all the dimensions and roles  associated with a given member.
 *
 * @param concept - $member - Passes a member to the function to determine the role and dimension.
 * @return dictionary - Returns a dictionary of the dimension, member and the role
**/
		
function get_member_dims($member)		
	$domain_member_role = filter taxonomy().networks(domain-member) returns $item.role;
	$list_dict = list(for ($network in $domain_member_role)
			$dim_items = navigate dimensions dimension-member ancestors from  $member role $network returns target;
			$dimension_list = filter $dim_items where $item in taxonomy().dimensions.concept returns $item.name;
			if $dimension_list.length == 0
			skip
			else
				for $x in range($dimension_list.length)
					dict(list('dimension', $dimension_list[$x]),list('member',$member),list('role',$network.uri)));
	$list_dict

/** 
 * tolerance_for_decimals
 * 
 * This function works out the tolerance between 2 values with different decimals with a tolerance factor.
 * 
 * @param factset - $left - Passes a factset value to compare to a second parameter called $right
 * @param factset - $right - Passes a factset value to compare to the first parameter called $left
 * @param integer - $decimal_tolerance_factor - Integer value that defines how different the values can be
 * @return boolean - Returns true if the two values provided are outside of the tolerance range.
**/

function tolerance_for_decimals($left, $right, $decimal_tolerance_factor)

	$left_decimal = if $left.decimals == none
						inf else $left.decimals;
						
	$right_decimal = if $right.decimals == none
						$left_decimal else $right.decimals;
						
	$tolerance1 = if ($left_decimal < $right_decimal) 
						$left_decimal
					else 	
						$right_decimal;
	$tolerance2 = if ($tolerance1 == inf) 
						0
					else 	
						(10.power(-1 * $tolerance1)) * $decimal_tolerance_factor;
						
	$left = if $left == none
				0
			else
				$left;

	$right = if $right == none
				0
			else
				$right;

	if (abs(round($left,$tolerance1) - round($right,$tolerance1)) > $tolerance2) 
		true
	else 
		false 


/** 
 * tolerance_for_decimals_comp
 * 
 * This function works out the tolerance between 2 values with different decimals with a tolerance factor and takes the minimum decimals from all facts for those cases where calc are used
 * and decimals are droppped.
 * 
 * @param factset - $left - Passes a factset value to compare to a second parameter called $right
 * @param factset - $right - Passes a factset value to compare to the first parameter called $left
 * @param decimal - $min_decimals - Passes a decimal that represents the lowest decimal value in the facts.  This is used if any of the decimals are none.
 * @param integer - $decimal_tolerance_factor - Integer value that defines how different the values can be
 * @return boolean - Returns true if the two values provided are outside of the tolerance range.
**/

function tolerance_for_decimals_comp($left, $right, $min_decimals, $decimal_tolerance_factor)

	/** This eliminates crazy values for decimals **/
	$min_decimals_adj = if $min_decimals == inf
							5
						else
							if $min_decimals > 5
								5
							else
								$min_decimals

	$left_decimal = if ($left.decimals == none or $left.decimals == inf)
						$min_decimals_adj else $left.decimals;
						
	$right_decimal = if ($right.decimals == none or $right.decimals == inf)
						$min_decimals_adj else $right.decimals;
						
	$tolerance1 = if ($left_decimal < $right_decimal) 
						$left_decimal
					else 	
						$right_decimal;
	$tolerance2 = if ($tolerance1 == inf) 
						0
					else 	
						(10.power(-1 * $tolerance1)) * $decimal_tolerance_factor;
						
	$leftSide = if ($left == none)
				0
			else
				$left;

	$rightSide = if ($right == none)
				0
			else
				$right;

	if (abs(round($leftSide,$tolerance1) - round($rightSide,$tolerance1)) > $tolerance2) 
		true
	else 
		false 

/** 
 * tolerance_for_decimals_greater_than
 * 
 * This function returns true if the first parameter is greater than the 2nd parameter after taking into account decimals and tolerance factor.
 * 
 * @param factset - $less - Passes a factset value to compare to a second parameter called $greater
 * @param factset - $greater - Passes a factset value to compare to the first parameter called $less
 * @param factset - $min_decimals - Passes a decimal that represents the lowest decimal value in the facts.  This is used if any of the decimals are none.
 * @param integer - $decimal_tolerance_factor - Integer value that defines how different the values can be
 * @return boolean - Returns true if the two values provided are outside of the tolerance range.
**/

function tolerance_for_decimals_greater_than($less, $greater, $minDecimals, $decimal_tolerance_factor)

	$less_decimal = if $less.decimals == none
						$minDecimals else $less.decimals;
						
	$greater_decimal = if $greater.decimals == none
						$minDecimals else $greater.decimals;
						
	$tolerance1 = if ($less_decimal < $greater_decimal) 
						$less_decimal
					else 	
						$greater_decimal;
	$tolerance2 = if ($tolerance1 == inf) 
						0
					else 	
						(10.power(-1 * $tolerance1)) * $decimal_tolerance_factor;
						
	$less = if $less == none
				0
			else
				$less;

	$greater = if $greater == none
				0
			else
				$greater;

	if (($less - $greater) > 0 )
		if (abs(round($less,$tolerance1) - round($greater,$tolerance1)) > $tolerance2)
			true
		else
			false
	else 
		false 

/** 
 * tolerance_for_decimals_greater
 * 
 * This function returns true if the first parameter is greater than the 2nd parameter after taking into account decimals and tolerance factor. (SIMPLE VERSION WITH TWO FACTS PASSED ONLY)
 * 
 * @param factset - $left - Passes a factset value to compare to a second parameter called $greater
 * @param factset - $right - Passes a factset value to compare to the first parameter called $less
 * @param integer - $decimal_tolerance_factor - Integer value that defines how different the values can be
 * @return boolean - Returns true if the two values provided are outside of the tolerance range.
**/
		
function tolerance_for_decimals_greater($left, $right, $decimal_tolerance_factor)
$lowest_decimal = if ($left.decimals < $right.decimals) 
					$left.decimals
				else 	
					$right.decimals;
$tolerance2 = if ($lowest_decimal == inf) 
					0
				else 	
					(10.power(-1 * $lowest_decimal)) * $decimal_tolerance_factor;

if (($left - $right) > 0 )
	if (abs(round($left,$lowest_decimal) - round($right,$lowest_decimal)) > $tolerance2)
		true
	else
		false
else 
	false 

/** 
 * division_intervals
 * 
 * This function returns a list of two intervals, the first being the lower bound and the second being the upperbound
 * of possible values for the result of the divisor. The function uses the decimals of the facts to determien the interval
 * 
 * @param factset - $numerator - Passes a factset value of the numerator
 * @param factset - $denominator - Passes a factset value as the denominator
 * @return list - Returns a list of the minimum value and the maximum value of the division.
**/

function division_intervals($numerator, $denominator)

	$numerator_decimals =  if $numerator.decimals == inf
								10
							else
								if $numerator.decimals == none
									0
								else
									$numerator.decimals

	$denominator_decimals =  if $denominator.decimals == inf
								10
							else
								if $denominator.decimals == none
									0
								else
									$denominator.decimals

	$numerator_interval_factor = (10.power(-1 * $numerator_decimals))/2;
	$denominator_interval_factor = (10.power(-1 * $denominator_decimals))/2

	$numerator_intervals = list(($numerator - $numerator_interval_factor),($numerator + $numerator_interval_factor));
	$denominator_intervals = list(($denominator - $denominator_interval_factor),($denominator + $denominator_interval_factor));

	$list_of_intervals = list(for $x in $numerator_intervals
								for $y in $denominator_intervals
								$x / $y
								)

	list(min($list_of_intervals), max($list_of_intervals))

/** 
 * division_of_intervals
 * 
 * This function returns a list of two intervals, the first being the lower bound and the second being the upperbound
 * of possible values for the result of the divisor. The function uses the provided intervals of the numerator and divisor
 * 
 * @param factset - $numerator - Passes interval of the numerator
 * @param factset - $denominator - Passes interval values as the denominator
 * @return list - Returns a list of the minimum value and the maximum value of the division.
**/

function division_of_intervals($numerator_intervals, $denominator_intervals)

	$list_of_intervals = list(for $x in $numerator_intervals
								for $y in $denominator_intervals
								$x / $y
								)

	list(min($list_of_intervals), max($list_of_intervals))
			
/** 
 * fact intervals
 * 
 * This function returns a list of two intervals, the first being the lower bound and the second being the upperbound
 * of possible values for the result of the fact. The function uses the decimals of the fact to determien the interval
 * 
 * @param factset - $factItem - Passes a factset value 
 * @return list - Returns a list of the minimum value and the maximum value of the fact.
**/

function fact_intervals($factItem)

	$fact_decimals =  if $factItem.decimals == inf
								10
							else
								if $factItem.decimals == none
									0
								else
									$factItem.decimals

	

	$fact_interval_factor = (10.power(-1 * $fact_decimals))/2;
	

	$fact_intervals = list(($factItem - $fact_interval_factor),($factItem + $fact_interval_factor));

	$fact_intervals

/** 
 * numerical intervals
 * 
 * This function returns a list of two intervals, the first being the lower bound and the second being the upperbound
 * of possible values for the result of a non fact value. The function uses the decimals of another fact to determien the interval
 * 
  *@param numericalValue - $number - Passes a numerical value 
 * @param fact_base - $factItem - Passes a factset value 
 * @return list - Returns a list of the minimum value and the maximum value of the fact.
**/

function numerical_intervals($numericalValue, $factBase)

	$fact_decimals =  if $factBase.decimals == inf
								10
							else
								if $factBase.decimals == none
									0
								else
									$factBase.decimals

	

	$fact_interval_factor = (10.power(-1 * $fact_decimals))/2;
	

	$fact_intervals = list(($numericalValue - $fact_interval_factor),($numericalValue + $fact_interval_factor));

	$fact_intervals

/** 
 * match_set_substring
 * 
 * This function determines if the name of the dimension member of a fact includes the sub-string passed in the second parameter.
 *
**/
	
function match_set_substring($fact, $match_member_string_component)
	any(set(for $x in $fact.dimensions-explicit.values.name.local-name.lower-case
		for $y in $match_member_string_component
		$y in $x))
	

/**
 * not_elim_adjust
 *
 * This function returns a boolean indicating if the fact has a dimension that can be negative. If true this means the fact does not have a valid reason to be negative.
 *
 * @param factset - $fact - Passes a fact to the function to determine if the fact has a dimension and member that allows it to be negative.
   @param list - $list - Passes a list of lists with axis member combinations that allow negatie values -> i.e. $EXCLUDE_NON_NEG_AXIS_MEMBERS
 * @return boolean - Returns a boolean of false if the value can be negative.
**/

function not_elim_adjust($fact, $non_neg_axis_members)

/* never touch this */
	all(set(
			for ($x in $non_neg_axis_members)
			/* get the axis name which is the first thing in the list */
				$axis_name = $x[1];

			/* get the set of elimination and adjustment members, which is the second thing on the list */
				$elim_adjust_members = $x[2];
				
				if ($fact.dimension($axis_name)!= none) 
					not $elim_adjust_members.contains($fact.dimension($axis_name).name)
				else
					true
			)
	)

/**
** isin_check
**
** This function checks that the ISIN number is valid relative to its check sum
**
** @param string - $isin The string representation of the isin number.
** @return boolean - Returns a boolean if the value passed is a valid ISIN.
**/

function  isin_check($isin)

	/** get a set of the Alpha Keys i.e. A, B, etc.**/
	$ASCIChars = $ALPHA_CODE_LOOKUP.keys;

	/** Return the check sum which is the last char of the string**/
	$checkSum = last(string_to_list($isin));

	/** Get the list of Chars without the checksum**/
	$charList = list(for $i in range($isin.length - 1)
					$isin.substring($i,$i));

	/** Replace ASCII Characters with numbers **/
	$replaceASCII = sum(list(for $x in $charList
								if $x in $ASCIChars
									$ALPHA_CODE_LOOKUP[$x].string
								else
									$x.string))

	/** split the string to a list **/
	$valuesAsList = string_to_list($replaceASCII);

	/** get the odd sequenced characters from the list **/
	$getOddChar = list(for $y in range(1,$valuesAsList.length,2)
						$valuesAsList[$y]);

	/** get the even sequenced chars from the list **/
	$getEvenChar = list(for $y in range(2,$valuesAsList.length,2)
						$valuesAsList[$y]);

	/** get the value to double **/
	$getDoubleChar = if mod($valuesAsList.length,2) == 0
						$getEvenChar
					else
						$getOddChar

	/** Double each of the values in the selected list**/
	$doubleValues = filter $getDoubleChar returns $item.number * 2;

	/** convert the double values to a string **/
	$convertDoubleValuesToString = sum(list(for $s in $doubleValues
												$s.string))

	/** Add odd or even list back to the double list **/
	$preSumValues = string_to_list($convertDoubleValuesToString) +
								if mod($valuesAsList.length,2) == 0
									$getOddChar
								else
									$getEvenChar;

	/** sum the single digit numbers after converting to a number **/
	$sumValues = sum(filter $preSumValues returns $item.number);

	/** Get the mod of the summed digits divided by 10 and deduct it from 10 **/
	$CheckSumPreCalc = 10 - mod($sumValues,10)
			
	/** turn a value of 10 into 0 **/
	$CheckSumCalc = mod($CheckSumPreCalc,10);

	/** check the calculated check sum matches the actual checksum **/
	$CheckSumCalc == $checkSum


/**
** figi_check
**
** This function checks that the FIGI number is valid relative to its check sum
**
** @param string - $figi The string representation of the figi number.
** @return boolean - Returns a boolean if the value passed is a valid figi.
**/

function  figi_check($figi)

	/** get a set of the Alpha Keys i.e. A, B, etc.**/
	$ASCIChars = $ALPHA_CODE_LOOKUP.keys;

	/** Return the check sum which is the last char of the string**/
	$checkSum = last(string_to_list($figi));

	/** Get the list of Chars without the checksum**/
	$charList = list(for $i in range($figi.length - 1)
					$figi.substring($i,$i));

	/** Replace ASCII Characters with numbers **/
	$replaceASCII = sum(list(for $x in $charList
								if $x in $ASCIChars
									$ALPHA_CODE_LOOKUP[$x].string
								else
									$x.string))

	/** split the string to a list **/
	$valuesAsList = string_to_list($replaceASCII);

	/** get the odd sequenced characters from the list **/
	$getOddChar = list(for $y in range(1,$valuesAsList.length,2)
						$valuesAsList[$y]);

	/** get the even sequenced chars from the list **/
	$getEvenChar = list(for $y in range(2,$valuesAsList.length,2)
						$valuesAsList[$y]);


	/** Double each of the values in the selected list**/
	$doubleValues = filter $getEvenChar returns $item.number * 2;

	/** convert the double values to a string **/
	$convertDoubleValuesToString = sum(list(for $s in $doubleValues
												$s.string))

	/** Add odd or even list back to the double list **/
	$preSumValues = string_to_list($convertDoubleValuesToString) + $getOddChar;

	/** sum the single digit numbers after converting to a number **/
	$sumValues = sum(filter $preSumValues returns $item.number);

	/** Get the mod of the summed digits divided by 10 and deduct it from 10 **/
	$CheckSumPreCalc = 10 - mod($sumValues,10)
			
	/** turn a value of 10 into 0 **/
	$CheckSumCalc = mod($CheckSumPreCalc,10);

	/** check the calculated check sum matches the actual checksum **/
	$CheckSumCalc == $checkSum

/**
** lei_check
**
** This function checks that the lei number is valid relative to its check sum
**
** @param string - $lei The string representation of the lei number.
** @return boolean - Returns a boolean of true if the value passed is a valid lei.
**/

function lei_check($lei)

	/** get a set of the Alpha Keys i.e. A, B, etc. **/
	$ASCIChars = $ALPHA_CODE_LOOKUP.keys;

	/** Get the list of Chars **/
	$charList = list(for $i in range($lei.length)
					$lei.substring($i,$i));

	/** Replace ASCII Characters with numbers **/
	$replaceASCII = sum(list(for $x in $charList
						if $x in $ASCIChars
							$ALPHA_CODE_LOOKUP[$x].string
						else
							$x.string))
	/** Add decimals so that the number function converts as a decimal and not an int.  An integer max value is exceeded**/
	$replaceASCII2 = $replaceASCII + ".00"
	
	/** turn into a number **/
	$numberValue = $replaceASCII2.number

	/** Get the checksum **/
	$CheckSum = mod($numberValue,97)

	$CheckSum == 1


/**
** string_to_list
**
** This function converts a string to a list of single characters.
**
** @param string - $stringItem The string representation of the value to put in a list.
** @return boolean - Returns a boolean if the value passed is a valid ISIN.
**/

function string_to_list($stringItem)

	list(for $f in range($stringItem.length)
					$stringItem.substring($f,$f))


/**
** CheckSum Function Constants
**
** Used tro support check sum functions. Many check sum functios turn Alpha numbers into digits.
**/

constant $ALPHA_CODE_LOOKUP = 	dict(
					list("A",10),
					list("B",11),
					list("C",12),
					list("D",13),
					list("E",14),
					list("F",15),
					list("G",16),
					list("H",17),
					list("I",18),
					list("J",19),
					list("K",20),
					list("L",21),
					list("M",22),
					list("N",23),
					list("O",24),
					list("P",25),
					list("Q",26),
					list("R",27),
					list("S",28),
					list("T",29),
					list("U",30),
					list("V",31),
					list("W",32),
					list("X",33),
					list("Y",34),
					list("Z",35))


/**
** getDimensionSums
**
** This function sums the values provided with a concept the cube and the drs-role
**
** @param concept - The concept associated with the fact that is to be summed acorss a given dmension.
** @param cube object - The cube objects  whose dimensions are aggregated  over.
** @param role uri - The drs role uri that defines the members that will be summed
** @return numeric - Returns a numerical value.
**/

function getDimensionSums($concept, $cube, $dimensions_of_sum, $parentConcept, $sum2)
			/** Identify Non Added dimensions **/
			$nonAddedDimensions = set('LegalEntityAxis','StatementScenarioAxis')

			/** Get the parent dimensions **/

			/**These have to be removed from any of the tests as we are already in that dimension **/
			$parentDimensions = sum(set({covered nonils @concept = $parentConcept @cube.drs-role = $cube.drs-role where $fact.dimensions.keys.count == ($dimensions_of_sum - 1)}.dimensions.keys))

			/** Get the dimensions in the cube **/
			
			$dimensions = sum(set({covered nonils @concept = $concept @cube.drs-role = $cube.drs-role where $fact.dimensions.keys.count == $dimensions_of_sum}.dimensions.keys)) - $parentDimensions
			if $dimensions == none
				skip
			else
			if $dimensions.length == 1 or $dimensions_of_sum == 1 or (((filter $dimensions.to-set returns $item.name.local-name) intersect $nonAddedDimensions).length > 0 and  $dimensions.length == 2)
				for $dim in $dimensions.name
					
					/** Want to exclude legal entity axis and statement scenerio axis as this is a dimension that is added **/

					if $dim.local-name in $nonAddedDimensions
						skip
					else 
						$members = navigate dimensions descendants from $dim drs-role $cube.drs-role returns target-name

						$domain = navigate dimensions dimension-domain descendants from $dim drs-role $cube.drs-role returns set target-name

						/** Get a set  of the unique members **/
						$member_descendants = $members.to-set - $domain;

						/** Generate a list of the member values to sum. It excludes member values that are included as a subtotal, by checking if a members ancestor has a value. If yes, then the value is excluded.**/


						$valid_facts = list(for $member in $member_descendants.to-list.sort
											$ancestors_list = (navigate dimensions domain-member ancestors from $member drs-role $cube.drs-role returns set (target-name)) - $domain;
											if $ancestors_list.length > 0
												if  list({ nonils @concept = $concept @cube.drs-role = $cube.drs-role @$dim in $ancestors_list}).length > 0
													skip
												else
													{nonils @concept = $concept @cube.drs-role = $cube.drs-role @$dim = $member  @@period = $sum2.period}
											else
												// This was added for those cases whener companies use a two dimensional breakdown of related party by counterpartyNameAxis. This caused
												// an issue when we added the period of sum2 that then forced alignment of the sum period which excluded CounterpartyNameAxis.
												if $dim.local-name == $FUNCTION_GET_DIMENSION_RELATED_PARTY_PAIR[1] 
													and $member.local-name == $FUNCTION_GET_DIMENSION_RELATED_PARTY_PAIR[2]  
													and missing([nonils @concept = $concept @cube.drs-role = $cube.drs-role @$dim = $member @@period = $sum2.period])
													{nonils @concept = $concept @cube.drs-role = $cube.drs-role @$dim = $member @$COUNTERPARTY_DIMENSION @@period = $sum2.period}
												else
													{nonils @concept = $concept @cube.drs-role = $cube.drs-role @$dim = $member @@period = $sum2.period});

												/** where  not $fact.dimensions().keys.name.local-name.contains('LegalEntityAxis') **/
						/** If there are no member facts the rule ends otherwise the subtotal is evaluated **/
						if 	$valid_facts.length == 0 
							skip
						else		
							/** aggregate the fact values on the axis **/
							sum($valid_facts)
			else
				
				/** Handles case where we have 2 dimensions in the financial statements **/

				$dimensionList = $dimensions.to-list
				if $dimensionList.length == 0
					skip
				else
				$dim = $dimensionList[1].name
				$dim2 = $dimensionList[2].name
					
				$members = navigate dimensions descendants from $dim drs-role $cube.drs-role returns target-name
				$members2 = navigate dimensions descendants from $dim2 drs-role $cube.drs-role returns target-name

				$domain = navigate dimensions dimension-domain descendants from $dim drs-role $cube.drs-role returns set target-name
				$domain2 = navigate dimensions dimension-domain descendants from $dim2 drs-role $cube.drs-role returns set target-name

				/** Get a set  of the unique members **/
				$member_descendants = $members.to-set - $domain;
				$member_descendants2 = $members2.to-set - $domain2;

				/** Generate a list of the member values to sum. It excludes member values that are included as a subtotal, by checking if a members ancestor has a value. If yes, then the value is excluded.**/

				$valid_facts = list(for $member in $member_descendants.to-list.sort
										$ancestors_list = (navigate dimensions domain-member ancestors from $member drs-role $cube.drs-role returns set (target-name)) - $domain;
										for $member2 in $member_descendants2.to-list.sort
											$ancestors_list2 = (navigate dimensions domain-member ancestors from $member2 drs-role $cube.drs-role returns set (target-name)) - $domain2;
											if ($ancestors_list.length > 0 or $ancestors_list2.length > 0) and list([nonils @concept = $concept @cube.drs-role = $cube.drs-role @$dim in $ancestors_list @$dim2 = $ancestors_list2]).length > 0
												skip
											else
												[nonils @concept = $concept @cube.drs-role = $cube.drs-role @$dim = $member @$dim2 = $member2 @@period = $sum2.period]
									);

										/** where  not $fact.dimensions().keys.name.local-name.contains('LegalEntityAxis') **/
				/** If there are no member facts the rule ends otherwise the subtotal is evaluated **/
				if 	$valid_facts.length == 0 
					skip
				else		
					/** aggregate the fact values on the axis **/
					sum($valid_facts)

/**
** getDimensionNames
**
** This function gets the dimension name values provided with a concept the cube and the drs-role
**
** @param concept - The concept associated with the fact that is to be summed acorss a given dmension.
** @param cube object - The cube objects  whose dimensions are aggregated  over.
** @param dimensions_of_sum - integer for how many dimensions
** @param parentConcept - qname of the parent for the calc
** @return list - Returns a numerical value.
**/

function getDimensionNames($concept, $cube, $dimensions_of_sum, $sum2)
			/** Identify Non Added dimensions **/
			$nonAddedDimensions = set('LegalEntityAxis','StatementScenarioAxis')

			/** Get the parent dimensions **/

			/**These have to be removed from any of the tests as we are already in that dimension **/
			$parentDimensions = sum(set({covered nonils @concept = $sum2.name @cube.drs-role = $cube.drs-role  where $fact.dimensions.keys.count == ($dimensions_of_sum - 1)}.dimensions.keys))

			/** Get the dimensions in the cube **/
			
			$dimensions = sum(set({covered nonils @concept = $concept @cube.drs-role = $cube.drs-role where $fact.dimensions.keys.count == $dimensions_of_sum}.dimensions.keys)) - $parentDimensions
			if $dimensions == none
				skip
			else
			if $dimensions.length == 1 or $dimensions_of_sum == 1 or (((filter $dimensions.to-set returns $item.name.local-name) intersect $nonAddedDimensions).length > 0 and  $dimensions.length == 2)
				for $dim in $dimensions.name
					
					/** Want to exclude legal entity axis and statement scenerio axis as this is a dimension that is added **/

					if $dim.local-name in $nonAddedDimensions
						skip
					else 
						$members = navigate dimensions descendants from $dim drs-role $cube.drs-role returns target-name

						$domain = navigate dimensions dimension-domain descendants from $dim drs-role $cube.drs-role returns set target-name

						/** Get a set  of the unique members **/
						$member_descendants = $members.to-set - $domain;

						/** Generate a list of the member values to sum. It excludes member values that are included as a subtotal, by checking if a members ancestor has a value. If yes, then the value is excluded.**/


						$valid_facts = list(for $member in $member_descendants.to-list.sort
											$ancestors_list = (navigate dimensions domain-member ancestors from $member drs-role $cube.drs-role returns set (target-name)) - $domain;
											if $ancestors_list.length > 0
												if  list({ nonils @concept = $concept @cube.drs-role = $cube.drs-role @$dim in $ancestors_list }).length > 0
													skip
												else
													{nonils @concept = $concept @cube.drs-role = $cube.drs-role @$dim = $member @@period = $sum2.period}
											else
												// This was added for those cases whener companies use a two dimensional breakdown of related party by counterpartyNameAxis. This caused
												// an issue when we added the period of sum2 that then forced alignment of the sum period which excluded CounterpartyNameAxis.
												if $dim.local-name == $FUNCTION_GET_DIMENSION_RELATED_PARTY_PAIR[1] 
													and $member.local-name == $FUNCTION_GET_DIMENSION_RELATED_PARTY_PAIR[2] 
													and missing([nonils @concept = $concept @cube.drs-role = $cube.drs-role @$dim = $member @@period = $sum2.period])
													{nonils @concept = $concept @cube.drs-role = $cube.drs-role @$dim = $member @$COUNTERPARTY_DIMENSION @@period = $sum2.period}
												else
													{nonils @concept = $concept @cube.drs-role = $cube.drs-role @$dim = $member @@period = $sum2.period});

												/** where  not $fact.dimensions().keys.name.local-name.contains('LegalEntityAxis') **/
						/** If there are no member facts the rule ends otherwise the subtotal is evaluated **/
						if 	$valid_facts.length == 0 
							skip
						else		
							/** aggregate the fact values on the axis **/
							list($dim.local-name,sum($valid_facts),$valid_facts)
			else
				
				/** Handles case where we have 2 dimensions in the financial statements **/

				$dimensionList = $dimensions.to-list
				if $dimensionList.length == 0
					skip
				else
				$dim = $dimensionList[1].name
				$dim2 = $dimensionList[2].name
					
				$members = navigate dimensions descendants from $dim drs-role $cube.drs-role returns target-name
				$members2 = navigate dimensions descendants from $dim2 drs-role $cube.drs-role returns target-name

				$domain = navigate dimensions dimension-domain descendants from $dim drs-role $cube.drs-role returns set target-name
				$domain2 = navigate dimensions dimension-domain descendants from $dim2 drs-role $cube.drs-role returns set target-name

				/** Get a set  of the unique members **/
				$member_descendants = $members.to-set - $domain;
				$member_descendants2 = $members2.to-set - $domain2;

				/** Generate a list of the member values to sum. It excludes member values that are included as a subtotal, by checking if a members ancestor has a value. If yes, then the value is excluded.**/

				$valid_facts = list(for $member in $member_descendants.to-list.sort
										$ancestors_list = (navigate dimensions domain-member ancestors from $member drs-role $cube.drs-role returns set (target-name)) - $domain;
										for $member2 in $member_descendants2.to-list.sort
											$ancestors_list2 = (navigate dimensions domain-member ancestors from $member2 drs-role $cube.drs-role returns set (target-name)) - $domain2;
											if ($ancestors_list.length > 0 or $ancestors_list2.length > 0) and list([nonils @concept = $concept @cube.drs-role = $cube.drs-role @$dim in $ancestors_list @$dim2 = $ancestors_list2 ]).length > 0
												skip
											else
												[nonils @concept = $concept @cube.drs-role = $cube.drs-role @$dim = $member @$dim2 = $member2 @@period = $sum2.period]
									);

										/** where  not $fact.dimensions().keys.name.local-name.contains('LegalEntityAxis') **/
				/** If there are no member facts the rule ends otherwise the subtotal is evaluated **/
				if 	$valid_facts.length == 0 
					skip
				else		
					/** aggregate the fact values on the axis **/
					list($dim.local-name,sum($valid_facts),$valid_facts)

/** 
 * most_frequent
 * 
 * This function will return the most frequent item in a list.
 * 
 * @param list - $listOfItems - Passes the list of items to determine the most common.
 **/
function most_frequent($list_of_items)
            $unique_items = $list_of_items.to-set;
            $index = dict(for $x in $unique_items
                        list((filter $list_of_items where $item == $x).length, $x)
            );
            $max_occurence = max(list(for $x in $unique_items
                                    (filter $list_of_items where $item == $x).length
                              )
                              )
            $index[$max_occurence]

/**
 * tolerance_for_decimals_sign_flip
 *
 * @param factset - $left - Passes a factset value to compare to a second parameter called $right
 * @param factset - $right - Passes a factset value to compare to the first parameter called $left
 * @param integer - $decimal_tolerance_factor - Integer value that defines how different the values can be
 * @param weight - $weight - value of 1 or -1 that determines if the sign is flipped
 * @return boolean - Returns true if the two values provided are outside of the tolerance range.
**/

function tolerance_for_decimals_sign_flip($left, $right, $decimal_tolerance_factor, $weight)
$tolerance1 = if ($left.decimals < $right.decimals) 
					$left.decimals
				else 	
					$right.decimals;
$tolerance2 = (10.power(-1 * $tolerance1)) * $decimal_tolerance_factor;

if (abs(round($left,$tolerance1) - round($right,$tolerance1)*$weight) > $tolerance2) 
	true
else 
	false 


function calculationExplananation($addendComponents, $cube, $concept_item, $fs_decimals, $sum2)
								sum(list(for $k in $addendComponents
													$targetElement = $k[3];
													
													$DefaultMessage =  if exists({nonils @concept = $targetElement @cube.drs-role = $cube.drs-role @@period=$sum2.period})
																			"" 
																		else 
																			$DimStringList = list(first-value(getDimensionNames($targetElement , $cube, 1, $sum2), getDimensionNames($targetElement , $cube, 2, $sum2)))
																			$DimString = filter $DimStringList returns $item[1].string + " Dim Facts: " + $item[3].join(' + ');
																			$DimString2 = $DimString.join(' | ');
																			" (" + $DimString2 + ")"
													
													$factAmt = $k[4]
														
													$factDecimals = $k[5]
													$weight =  if $k[2] == 1
																		"+"
																else
																		"-";
													$strLength = $targetElement.local-name.string.length;
													$pad = sum(list(for $x in range(120 - $strLength - $factAmt.length - $DefaultMessage.length)
																					" " 
																					)
																			);
											"" + $weight + "  \t" + $targetElement.local-name.string + $DefaultMessage + $pad + $factAmt  +  (if $factDecimals < $fs_decimals " (Inconsistent decimals: " +  $factDecimals.string + " )" else skip)  + "\n"
													)
									)
/**
 * duration_contained 
 *
 * @param duration - $smallDate - Passes a duration to check if it is in the larger duration
 * @param duration - $largeDate- Passes a duration to check if a smaller duration is contained within.
 
 * @return boolean - Returns true if the one duration is contained within another duration.
 *
**/
function duration_contained($smallDate,$largeDate)
		
		if $smallDate.start >= $largeDate.start and $smallDate.end <= $largeDate.end
			if $smallDate.start == $largeDate.start and $smallDate.end == $largeDate.end
				false
			else
				true
		else
			false

/** used in DQC 00182 **/

function concept_pair_from_name_pair($pair)

	list(taxonomy().concept($pair[1]),taxonomy().concept($pair[2]))

/**
 *applicable_form()
 *
 * @param string - The full rule name such as DQC.0001.100

 
 * @return boolean - Returns true if the rule should run on the applicable form type.
 *
**/


function applicable_form($ruleName)
		$rule_number = ($ruleName.split('.'))[($ruleName.split('.').length)-1];
		$ApplicableForms = $RULE-FORM-LOOKUP[$rule_number]
		$ApplicableForms.contains($DOCUMENT_TYPE) or  $DOCUMENT_TYPE == none or $ApplicableForms == none

/**
 *applicable_form()
 *
 * @param string - The rule number such as 100

 
 * @return boolean - Returns true if the rule should run on the applicable form type.
 *
**/


function applicable_form_string($ruleNnumber)
		$ApplicableForms = $RULE-FORM-LOOKUP[$ruleNnumber]
		$ApplicableForms.contains($DOCUMENT_TYPE) or  $DOCUMENT_TYPE == none or $ApplicableForms == none



/** THis function is intended to check that the investment identifier axis member meets a specific format
* The function checks that the name of the identifier for the investment is standardized so that it can be used by data users if the EE is not used to identify the investments attribute.
* The rule checks the qname of the member on the investmentIdentifier axis has the following values delimited by a _ character:
* 1. Value of DEBT or EQUITY  or OTHER - required cannot be empty
* 2.Issuer name (no spaces or special characters) - required cannot be empty
* 3. If the security is Affiliated or Unaffiliated  - required cannot be empty
* 4. The industry of the security or loan  - required can be empty but should be none
* 5. The geography of the security or loan - required can be empty but should be none
* 7. The security type of the security or loan (Secured or Unsecured etc.) - optional
* 8. The maturity of the security or loan (Date) - Optional
* 9. The interest rate of the security or loan (Rate) - Optional
**/

function investmentMemberFormat($member)
/**
Checks that an investment identifier member local-name follows the expected
    underscore delimited format described in the function header.
    Required components:
     1. Type: DEBT | EQUITY | OTHER
     2. Issuer: non-empty, no spaces
     3. Affiliation: AFFILIATED | UNAFFILIATED
    Optional components (positions shown if present):
     4. Industry: 'none' or non-empty (no spaces)
     5. Geography: 'none' or non-empty (no spaces)
     6. SecurityType: optional
     7. Maturity: optional
     8. InterestRate: optional
    Returns a list with boolean and message.
    **/
    $member_name = if $member == none "" else $member.name.local-name.string
    $parts = $member_name.split('_')

    /* must have at least 3 components */
    if $parts.length < 3
        list(false, "Less than 3 components cmprising the member name")
    else
        $primary = $parts[1].upper-case
        $issuer = if $parts.length >= 2 $parts[2] else ""
        $affiliation = if $parts.length >= 3 $parts[3].upper-case else ""
        $industry = if $parts.length >= 4 $parts[4] else "none"
        $geo = if $parts.length >= 5  $parts[5] else "none"

        /* basic validations */
        $ok_primary = $primary in set('DEBT','EQUITY','OTHER')
        $ok_issuer = ($issuer.length > 0) and (not $issuer.contains(' '))
        $ok_affiliation = $affiliation in set('AFFILIATED','UNAFFILIATED')

        /* industry and geography may be empty signalled by 'none' or must not contain spaces */
        $ok_industry = ($industry == "none") or (($industry.length > 0) and (not $industry.contains(' ')) and (not $industry.contains('Member')))
        $ok_geo = ($geo == "none") or (($geo.length > 0) and (not $geo.contains(' ')))

        if $ok_primary and $ok_issuer and $ok_affiliation and $ok_industry and $ok_geo
            list(true, "All components valid")
        else
            list(false, "Security Type valid:" + $ok_primary.string + ", Issuer valid:" + $ok_issuer.string + ", Affiliation valid:" + $ok_affiliation.string + ", Industry valid:" + $ok_industry.string + ", Geography valid:" + $ok_geo.string)